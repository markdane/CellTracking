

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(RColorBrewer)
library(DT)

###debug to run standalone from calling script
path <- "/Users/dane/Documents/CellTracking/MTrackJ/Data/LI2042_A2_1_Points.csv"
```

```{r}

df_input <- read_csv(paste0(path), col_types = cols(
  Nr = col_double(),
  TID = col_double(),
  PID = col_double(),
  `x [pixel]` = col_double(),
  `y [pixel]` = col_double(),
  `t [min]` = col_double(),
  `I [val]` = col_double(),
  `Len [pixel]` = col_double(),
  `D2S [pixel]` = col_double(),
  `D2R [pixel]` = col_logical(),
  `D2P [pixel]` = col_double(),
  `v [pixel/min]` = col_double(),
  `α [deg]` = col_double(),
  `Δα [deg]` = col_double()
)) 

colnames(df_input) <- str_replace_all(colnames(df_input),"[ [:punct:][:blank:]]" ,"")

```

Extract the intensity values into a full matrix with cell number as the column names and time as the row names. Write these values to a file named `r out_filename` with empty strings in place of the missing data.  

```{r format_intensities}
df_intensities <- tibble(time = rep(unique(df_input$tmin), each = length(unique(df_input$TID))),
              cell = rep(unique(df_input$TID), times = length(unique(df_input$tmin)))) %>%
  left_join(df_input, by = c("time" = "tmin", "cell" = "TID")) %>%
  select(time, cell, Ival) %>%
  spread(cell, Ival)
# 
# datatable(df_intensities, caption = "Intensities of every cell over time")

# filename <- paste(plateID,well, field, "intensities.csv",sep = "_")
# res <- write_csv(df_intensities,
#                  paste0(out_filename),
#                  na = "")
```

Plot cell migrations using a repeating, diverging pallette. Each dot is a cell. The first figure shows the absolute locations. The second figure shows the relative position from the cells initial position. The third figure shows the relative motion with fixed x and y axis limits.  


```{r plot_migration, fig.width=4, fig.height=4}
df <- df_input %>%
  select(TID, tmin, Ival)

cols <- RColorBrewer::brewer.pal(9, name = "Set1")[sample(1:9, length(unique(df$TID)), replace = TRUE)]

p <- ggplot(df_input, aes(xpixel, ypixel, colour = factor(TID))) +
  geom_point(size = .5, alpha = .8) +
  geom_path(size = .5, alpha = .8) +
  scale_colour_manual(values = cols) +
  guides(colour = FALSE) +
  theme_bw()
p

T0_tracks <- df_input %>%
  filter(tmin == 0)

T0_rel <- df_input %>%
  filter(PID == 1) %>%
  select(TID, xpixel, ypixel) %>%
  rename(x_T0_rel = xpixel,
         y_T0_rel = ypixel) %>%
  right_join(df_input, by = "TID") %>%
  mutate(x_rel = xpixel-x_T0_rel,
         y_rel = ypixel-y_T0_rel) %>%
  select(x_rel, y_rel, TID) %>%
  drop_na()

cols <- RColorBrewer::brewer.pal(9, name = "Set1")[sample(1:9, length(unique(T0_rel$TID)), replace = TRUE)]


p <- ggplot(T0_rel, aes(x_rel, y_rel, colour = factor(TID))) +
  geom_point(size = .5, alpha = .8) +
  geom_path(size = .5, alpha = .8) +
  scale_colour_manual(values = cols) +
  guides(colour = FALSE) +
  theme_bw()
p

p <- ggplot(T0_rel, aes(x_rel, y_rel, colour = factor(TID))) +
  geom_point(size = .5, alpha = .8) +
  geom_path(size = .5, alpha = .8) +
  coord_cartesian(xlim = c(-600, 600), ylim = c(-600,600)) +
  scale_colour_manual(values = cols) +
  guides(colour = FALSE) +
  theme_bw()
p
```


```{r identify_divisions, fig.width=6, fig.height=5}

#### Mother/daugther relationships
# 
# Assumptions:
# The TID of the mother cell stops.  
# In the next time slot 2 new TIDs for daughter cells begin within close proximity of the last position of the mother cell.  
# 

#label 0 if there is no cell and 1 if there's a cell
label_status <- function(x){
  y <- rep(0, length(x))
  y[!is.na(x)] <- 1
  return(y)
}

# return a vector that identifies when a cell is born or dies
#  x[t+1] - x[t] = 0 if no change
#                = -1 if a cell dies 
#                = 1 if a cell is born

label_changes <- function(x){
  x_t_plus_1 <- x
  x_t <- c(x[1], x[1:(length(x)-1)])
  y <- x_t_plus_1 - x_t
  
  return(y)
}

# return a vector that identifies the time before a cell dies
#  x[t+1] - x[t] = 0 if no change
#                = -1 if a cell will die 
#                = 1 if a cell is born

label_last_time <- function(x){
  y <- c(x[2:length(x)], x[length(x)])
  y[y==1] <- 0
  return(y)
}

#Add status and changes of birth and death
new_tracks <- df_intensities %>%
  gather(cell, intensity, -time) %>%
  group_by(cell) %>%
  mutate(status = label_status(intensity),
         changes = label_changes(status),
         last_time_measured = label_last_time(changes)) %>%
  ungroup() %>%
  mutate( cell = as.numeric(cell))

#Get position of new cells
tracks_with_births <- new_tracks %>%
  filter(changes == 1) %>%
  rename(cellID = cell) %>%
  select(time, cellID) %>%
   left_join(df_input, by = c("cellID" = "TID", "time" = "tmin")) %>%
  select(time, cellID, xpixel, ypixel)

#Get last position of disappearing cells
tracks_last_time <- new_tracks %>%
  filter(last_time_measured == -1) %>%
  rename(mother = cell) %>%
  select(time, mother) %>%
  left_join(df_input, by = c("mother" = "TID", "time" = "tmin")) %>%
  select(time, mother, xpixel, ypixel)

position_threshold <- 25
time_threshold <- 15

#get mother IDs for tracks that start after time 0
#find a cell that disapeared in this time slot and was nearby in the time slot before the birth
select_IDs <- function(x) {
  IDs <- tracks_with_births %>%
  mutate(time_diff = abs(time - x["time"]),
         position_dif = sqrt((x["xpixel"]-xpixel)^2+(x["ypixel"]-ypixel)^2)) %>%
  filter(time_diff <= time_threshold,
         position_dif <= position_threshold,
         !time_diff == 0) %>%
    mutate(motherID = x["mother"]) %>%
    select(motherID, cellID)
  return(IDs)
}

#find all birth events based on proximity of track end to tracks beginning
all_births <-  apply(tracks_last_time, 1, select_IDs) %>%
  bind_rows()

first_gen <- df_input %>%
  filter(tmin == 0) %>%
  select(TID) %>%
  rename(cellID = TID) %>%
  mutate(motherID = 0,
         generation = 1,
         lineage = cellID) %>%
  select(motherID, cellID, generation, lineage)


#find all births with mothers in the first generation
second_gen <- all_births %>%
  inner_join(first_gen, by = c("motherID" = "cellID")) %>%
  select(motherID, cellID, lineage) %>%
  mutate(generation = 2)%>%
  filter(!(motherID == cellID))

#find all births with mothers in the second generation
third_gen <- all_births %>%
  inner_join(second_gen, by = c("motherID" = "cellID")) %>%
  select(motherID, cellID, lineage) %>%
  mutate(generation = 3)%>%
  filter(!(motherID == cellID))

fourth_gen <- all_births %>%
  inner_join(third_gen, by = c("motherID" = "cellID")) %>%
  select(motherID, cellID, lineage) %>%
  mutate(generation = 4)%>%
  filter(!(motherID == cellID))

fifth_gen <- all_births %>%
  inner_join(fourth_gen, by = c("motherID" = "cellID")) %>%
  select(motherID, cellID, lineage) %>%
  mutate(generation = 5)%>%
  filter(!(motherID == cellID))

sixth_gen <- all_births %>%
  inner_join(fifth_gen, by = c("motherID" = "cellID")) %>%
  select(motherID, cellID, lineage) %>%
  mutate(generation = 6) %>%
  filter(!(motherID == cellID))

lineages_generations <- bind_rows(first_gen,
                                  second_gen,
                                  third_gen,
                                  fourth_gen,
                                  fifth_gen,
                                  sixth_gen)


#Add the mother IDs to each daughter
df_lineage <- df_input %>%
  left_join(lineages_generations, by = c("TID" = "cellID"))

df_lineage$motherID[is.na(df_lineage$motherID)] <- df_lineage$TID[is.na(df_lineage$motherID)]

p <- ggplot(df_lineage, aes(xpixel, ypixel, colour = factor(lineage))) +
  geom_point(size = .5, alpha = .6) +
  #geom_path(size = .5, alpha = .8) +
  #scale_colour_manual(values = cols) +
  guides(colour = FALSE) +
  labs(title = "Colored by lineage") +
  theme_bw()
p

p <- ggplot(df_lineage, aes(xpixel, ypixel, colour = factor(generation))) +
  geom_point(size = .5, alpha = .8) +
  #geom_path(size = .5, alpha = .8) +
  #scale_colour_manual(values = cols) +
  #guides(colour = FALSE) +
  labs(title = "Colored by generation") +
  theme_bw()
p
```

```{r lineagedistributions, fig.width=4, fig.height=5}
#count and didplay the number of cells in each lineage
df <- df_lineage %>%
  select(lineage, TID) %>%
  distinct() %>%
  group_by(lineage) %>%
  summarise(count = n()) %>%
  ungroup()
p <- ggplot(df, aes(x = count)) +
  geom_histogram(binwidth = 1)
p

p <- ggplot(df, aes(x = count,fill = "cornflower")) +
  geom_density( alpha = .5) +
  guides(fill = FALSE) +
  labs(x = "Cells per lineage") +
  coord_cartesian(xlim = c(1,25))
p

```

```{r lineagePlots, fig.width=9, fig.height=8}
#plot presence of cells vs time and grouped by lineage
p <- ggplot(df_lineage, aes(x = tmin, y = TID, colour = factor(lineage))) +
  geom_point() +
  scale_color_ordinal() +
  guides(color = FALSE)
p

p <- ggplot(df_lineage, aes(x = tmin, y = TID, color = generation)) +
  geom_point(size = 1,  stroke = .01) +
  facet_wrap(~lineage, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 90))
p

```

#### MTrackJ file features

    Nr: The measurement number. Runs from 1 to the total number of points.

    CID: The ID number of the cluster to which the track point belongs. This quantity is not displayed if there is only one cluster and the user has deselected the displaying of cluster and assembly measurements.

    TID: The ID number of the track to which the point belongs.

    PID: The ID number of the point.

    x [unit]: The calibrated x coordinate of the point. The pixel width and unit of length used here can be set as described above.

    y [unit]: The calibrated y coordinate of the point. The pixel height and unit of length used here can be set as described above.

    z [unit]: The calibrated z coordinate of the point. The voxel depth and unit of length used here can be set as described above. This quantity is not displayed in the case of 2D image sequences.

    t [unit]: The calibrated t coordinate of the point. The frame interval and unit of time used here can be set as described above.

    c [idx]: The channel index of the point. This quantity is not displayed if there is only one channel.

    I [unit]: The calibrated image intensity value at the point. For 8-bit and 16-bit images, the intensity calibration function and value unit can be set (if necessary) as described above. For RGB-images, the intensity is computed as I = 0.3R + 0.6G + 0.1B. If the Edit > Options > Display > Interpolate Zoomed Images option of ImageJ is selected, the (calibrated) intensities are linearly interpolated where necessary (subpixel coordinate precision).

    Len [unit]: The length of the track from the start (first) point of the track to the current point (inclusive). Thus the value of this quantity for the end (last) point of a track equals the total length of the track. The pixel calibration and unit of length used here can be set as described above.

    D2S [unit]: The distance from the start (first) point of the track to the current point. Thus the value of this quantity is always less than (or at most equal to) the value of Len. The pixel calibration and unit of length used here can be set as described above.

    D2R [unit]: The distance from the current point to the reference point (see the description of the Refer button for information on how to set the reference). The pixel calibration and unit of length used here can be set as described above.

    D2P [unit]: The distance from the current to the previous point of the track. The pixel size and unit of length can be set as described above.

    v [unit]: The speed, at the current point, of the object represented by the track. This quantity is computed as the magnitude of the most recent displacement vector (pointing from the previous point to the current point of the track), divided by the frame interval. The pixel calibration, unit of length, frame interval, and unit of time can be set as described above.

    α [deg]: The angle of the in-plane component of the most recent displacement vector (pointing from the previous point to the current point of the track) with respect to the x-y coordinate system of the image (with the origin taken in the previous point). Angle values range from -180 to +180 degrees, where 0 degrees means the vector component runs parallel to the positive x axis (pointing to the right), +90 degrees (or -90 degrees) means it runs parallel to the positive (or negative) y axis (pointing downward, or upward, respectively), and +180 degrees (which is the same as -180 degrees) means it runs parallel to the negative x axis (pointing to the left). The pixel calibration can be set as described above.

    Δα [deg]: The angular change between the in-plane components of the most recent displacement vector (pointing from the previous point to the current point of the track) and the preceding displacement vector. The pixel calibration can be set as described above.

    θ [deg]: The angle of the most recent displacement vector (pointing from the previous point to the current point of the track) relative to the x-y plane of the image (with the origin taken in the previous point). The angle values range from -90 to +90 degrees, where 0 degrees means the axial vector component is zero (that is, the displacement vector is entirely in-plane), and +90 degrees (or -90 degrees) means it runs parallel to the positive (or negative) z axis (pointing away from, respectively toward, the observer). The pixel calibration can be set as described above. This quantity is not displayed in the case of 2D image sequences.

    Δθ [deg]: The angular change between the most recent displacement vector (pointing from the previous point to the current point of the track) and the preceding displacement vector, relative to the x-y plane of the image. The pixel calibration can be set as described above. This quantity is not displayed in the case of 2D image sequences.
